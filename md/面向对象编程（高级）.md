## 面向对象编程（高级）
在这一章将面向对象编程的所有内容完全补充，讲完了类的五大组成部分，即：属性、方法、构造器、代码块、内部类。接下来一一道来
### 静态变量（类变量）
和c的静态变量相似，存储在方法区（静态区），整个程序共享变量。其定义为
```java
【访问修饰符】static【类型】【变量名】
```
 除此之外，还有一些要点。

1. 首先静态变量也可以通过访问修饰符修饰，仍然遵从访问权限
2. 其次，静态变量的调用也多了一种：类名.变量名，并且更加推荐这种方式，可以避免创建对象。
3. 在Java中静态变量在类的加载时就已经创建，直到类的消亡才消亡。关于类加载在稍后会讲
4. 当使用方法来给变量赋值时，这个方法只能时静态方法

### 静态方法（类方法）
当想要使用某种方法但又不想创建对象时就可以使用静态方法（如，Math方法），其与静态变量类似，都存在方法区，都可以通过类名.方法名调用，其定义为
```java
【访问修饰符】static【返回类型】【方法名】(){}
```
此外还有一些细节

1. 首先，和静态变量一样，静态方法只能调用静态变量和静态方法，而普通方法都可以调用。
2. 静态方法中没有this和super，连隐含的this都没有(上一章说过普通方法有),所以当形参和方法中变量名相同时，应该使用
```java
[类名].[属性]=[形参]
```

### main()
现在就可以深入了解main方法了
```java
public static void main(String arg[]){}
```

1. 首先这是一个公有方法，为什么？因为main方法由JVM机来调用，JVM机和main不同包
2. 然后是一个静态方法，因为调用main方法不需要调用对象
3. 再然后没有返回值，这没啥说的
4. 最后形参为String 的一个数组,args[],这就有问题了，使用main方法我们没有传过值啊，如果要传值又该怎么传？ 先说第二个问题，怎么传数组，这个在cmd界面更明显
```java
java【程序名】【参数1】【参数2】...
```
实际上arg[]就是我们传的数组，但一般而言，数组都没有参数。在程序里我们是可以使用args数组的，如
```java
public static void main(String[] args) {
    // 虽然声明了参数，但程序逻辑不需要使用它
    if (args.length == 0) {
        System.out.println("没有传入参数");
    } else {
        System.out.println("传入了 " + args.length + " 个参数");
    }
}
```

更深入一点，其实main方法也是在一个公共类之中，在这个公共类中也可以有其他的属性，然后再在main之中调用。

### 代码块
又称为初始化块，是我们学的类的第四个组成部分，类似于方法，执行代码由{}包起来，其定义为：
```java
(可选static){
	执行代码;
};
```
特别注意{}之后有'；'因为代码块也是类的一部分，要用分号隔开。{}之前的static可以选择是否写入，如果有那就是静态代码块。对于静态代码块和其他静态成员一样，只能调用静态成员，当类加载时，静态代码块就会执行，那么类加载是什么情况呢？

1. 创建对象（实例）时；
2. 子类创建实例时；
3. 类的静态成员被调用时；

特别注意：类加载在整个程序中只会被加载一次，如果上述三种情况发生多次，也只会加载一次。
好了，那疑问来了，代码块什么时候执行呢？其在类中的调用顺序是什么样的呢。
这里分三步：

1. 程序先判断是否有父类，如果有就加载父类，加载父类也依照第二步来执行静态成员，之后到子类加载
1. 类加载：此时静态属性，静态方法，静态代码块初始化，此时静态代码块的代码执行，这三者按在程序中的先后顺序进行，如果静态属性需要调用某一个方法，这个方法会先加载和执行。
2. 如果是创建实例，那么，此时就会调用构造器，但就像构造器中隐含super()，构造器中也隐含调用普通代码块，所以在调用构造器之前，会先对父类的普通代码块和普通属性初始化，然后对子类的普通代码块和普通属性初始化，普通代码块和普通属性优先级相同。最后才是加载构造器。
#### static
到此，其实对于静态的特性已经完全了解，即：类加载时会加载，只能调用静态成员

### final
正如其意思一样，如果想要一个成员是最后的，即：类不能被继承，方法不能被重写，属性不能被更改。就用到final。一般而言，final都用在访问修饰符之后，类用在class之前。
此外还有一些细节：

1. 当属性被final修饰其实就是常量，属性名全大写，用_分隔。在属性定义时，属性赋值可以在定义时赋值，或者在构造器中赋值，或者在代码块中赋值，并且赋值之后无法修改，如：
```java
class test{
	public final AGE = 100;
	public test(int age){
		AGE = age;
	}
	{
		AGE=100；
	}
}
```
但如果属性同时是static 和final就不能在构造器中赋值，因为初始化顺序不同，但这种方式效率更高，因为编译器为此做了优化

2. 当类被final修饰时，代表这个类不能被继承，但也可以实例化对象。注意，Interger,Double,Float,Boolean等包装类都被final修饰了。
3. 当方法被final修饰，代表这个方法不能被重写。一般如果类已经是final，方法就不会用final修饰。 

### 抽象类
如果很多类继承同一个类，但这些类的方法又有些不同（如：每个动物一个类，eat方法就不同），此时就可以把这个父类做成抽象类，把这个方法做成抽象方法。定义为：
```java
abstract class 类名{
	public abstract void eat(){}
}
```
细节：

1. 一个类一旦有抽象方法，这个类就一定要是抽象类，但一个抽象类却可以拥有普通方法，也可以拥有任意成员，像一个正常的类。
2. 抽象方法不能有主体，即不能有{}。也不能有private,static ,final,不然怎么继承。。。
3. 一个类如果继承了抽象类，就要实现抽象类的所有抽象方法。

### 接口
简单来说，接口就是为了弥补一个类只能继承一个父类的缺点，其和抽象类很相似，定义为：
```java
interface 接口名{
	属性；
	方法；
}
```
当一个类要实现接口时，方式为：
```java
class 类名 implements 接口{
	自己的属性；
	自己的方法；
	实现接口的抽象方法；
	}
```

1. 对于接口中的属性来说 ，其一定为public final static属性的，即便在定义时是 int age 在编译时也会被看作public final static int age 并且，在定义时属性就要被初始化。由于接口是static的，所有可以通过【接口名】.【属性】来调用。
2. 对于接口中的方法来说，默认其方法为抽象方法，不用写方法体，亦可以不用写abstract。所以，实现接口的类，就要实现接口的所有方法，不过有个特例，那就是抽象类，可以不实现，符合抽象类的特点。在jdk8之后，接口可以有静态方法和普通方法了，静态方法加上static，这没什么好说的，但普通方法在最前面要加上default。

### 内部类
这是类的最后一个组成部分。简单来说，内部类就是在类之中再塞一个类，其中，包裹内部类的类称为外部类，与外部类平级的其他类称为外部其他类。根据内部类位置可以分为两个部分，一个在构造器、方法之中，一个在与其他四个组成部分平级。前者又可以分为局部内部类和匿名内部类，后者也可以分为成员内部类和静态内部类。
但他们都有共同的特点，就是可以使用外部类的所有成员，包括私有成员。现在我们一一来看：
- 局部内部类
定义
``` java
class Test{
	public void test{
		class Inner{}
	}
}
```

1. 刚刚也说了，局部内部类在方法等成员中，所有他的地位就像在方法中创建的局部变量，因此，他不能加访问修饰符，但可以使用final（就像局部变量也有常量一样）。
2. 对于访问的问题，如果是局部内部类访问外部类的成员，可以直接访问，但如果是外部类访问内部类，就要在包裹内部类的方法中创建内部类的对象，通过对象来调用内部类。如果是外部其他类访问内部类，则无法访问，就像无法获取一个其他类方法中的变量一样。
3. 对于属性重名的问题，如果内部类的一个属性和外部类的属性重名，则遵循就近原则，如果想要使用外部类的属性，就要用 [外部类名].this.[属性名]来调用。

- 匿名内部类
 这是一个非常重要的知识点，如果有一个类在这个程序中只使用一次，就会用到，这在jdk源码中使用非常广泛，他的定义为
 ``` java
 class B{}
 interface C{}
 class A{
	 public void a1(){
		 B b=new B(){}
		 C c =new C(){}
     }
}
```
b是基于类的匿名内部类，c是基于接口的匿名内部类。无论是哪种，他的本质仍是继承或实现。在jdk源码中可知，匿名内部类其实并不是没有名字，而是由系统分配名字，然后创建了一个类来继承或实现，这也就意味着如果是基于接口的匿名内部类就要实现接口的所有抽象方法。

1. 匿名内部类对外部类成员的访问、调用和属性重名处理方法和局部内部类相同。只不过在调用其方法时是多了一个：由于其没有名字，所有可以直接在匿名内部类结束的{}之后用.[方法名]或者直接b.[方法名]来调用其方法。
2. 本质上在第一行new时已经为匿名内部类创建了对象(b或c)，所以这里也有编译类型和运行类型之分，对于例子来说，编译类型就是B或者C，运行类型就是匿名内部类。

这里再提一句，匿名内部类最大的特点就是可以直接作为实参来传参，如果要求传入一个B类型的实参，就可以直接用匿名内部类继承B来传参。

- 成员内部类
就像他的名字一样，他是类的一个成员，与属性、构造器等成员变量一样。与上面两个方法有本质区别，那就是他不在方法体内。定义方式与正常的类相同。接下来说一下他的细节：

1. 因为是一个成员，所以他也有访问修饰符。
2. 他的作用域是整个外部类。
3. 对于访问方法，外部类同样需要创建对象，这个对象可以在外部类的任意地方创建，而外部其他类也可以访问，但也需要创建对象，创建方式为：
```java
[外部类名].new [内部类名]
//注意，这里也要用[外部类名].[内部类名]来接收
//可以看作外部类的内部类要new
//或者也可以在外部类中写一个方法，然后返回内部类的对象
```
4. 对于重名处理，与上面两者相同

- 静态内部类
正如他的名字，这是一个静态的成员内部类，所以也有访问修饰符。定义方式与正常类多了一个static。接下来是一些细节：
5. 由于是静态类，所以他只能直接访问外部类的静态成员，外部类访问与成员内部类一样，但外部其他类访问有区别，它可以在外部类的方法中返回，这是一样的，但如果想要在外部其他类创建对象，则需要
```java
new [外部类].[内部类]
//一样需要[外部类].[内部类]类型来接收
```

好了，以上就是高级面向对象编程的知识点了，现在面向对象编程已经学完了。我觉得他与面向过程编程的最大区别就是对象的能力太强了，一切需求基本都可以在对象中完成，甚至是if语句或for语句也可以放进对象中。现在感悟还不强，等我深入体会之后再来写吧。
