## 面向对象编程
学完了类与对象后，学了怎么利用面对对象编程，在这一阶段几乎所以的操作都是在类之中完成，编程软件也从subline变成了IDER，变化非常大，在软件中就可以看到项目 的结构，并且还有很完善的纠错系统和提示系统，很方便，之后就学了包、访问修饰符，然后学了面向对象的三大特征：封装，继承，多态，并以此为基础衍生出很多的知识点。下面是详细说明
### IDEA
这只是一个软件，但有很多提升效率的快捷键
1. 删除当前行：ctrl+d
2. 复制当前行：ctrl+alt+向下
3. 补全代码：tab
4. 添加注释和取消注释：crul+/[第一次是添加，第二次是删除
5. 自动导入需要的类：要在设置中开启auto import然后就可以自动添加，当然也可以alt+enter手动添加
6. 快速整理代码：ctul+alt+L（很好的方法，不用再自己一个个缩进了
7. 快速运行程序：ctul+R
8. 生成构造器、setting&getting等封装相关的工具：alt+INS
9. 查看一个类的层级关系：ctrl+H
10. 定位类的方法：ctrl+B
11. 自动分配变量名：定义对象之后在后面加.var
除了这些快捷键，还有很多，我也在这里立个flag，每两天学一个新的快捷键。在用subline时总是觉得Java很麻烦，但现在用了这个集成度更高的ide舒服多了，终于有了和vs一样的舒服感
### 包（package）
层级在项目之下，在类之上，可以粗略的理解为一个软件中的一个功能就是一个包
1. 包的命名：
- 规则：只能包含数字，字母，下划线，小圆点(.)，但不能以数字开头，可以包含关键词和保留词，但不能就是关键词和保留词
- 规范：一般为小写字母+小圆点：com.公司名.项目名.业务模块名
2. 常用包：
- java.lang:Java基本包，默认引入，不需要再引入
- java.uril:系统提供的工具包，工具类
- java.net:网路包，网络开发
- java.awt:Java页面开发
3. 细节：
- package的作用是声明当前类所在包(自建包)，要放在最上面，一个类只有一个
- import(系统包)在package之后，没有数量限制
### 访问修饰符
用于控制方法和属性的访问权限
1. public:公开级，在当前项目中都可以调用
2. protected:受保护级，不同包的非子类不能用，但不同包的子类可以用
3. 默认：即什么都不写，只有在同包才能用
4. private:限制级，只有同类能用
### 封装(encapsulation)
总结来说：就是将属性和方法用private修饰，再提供公开的方法来调用这些被限制的属性和方法。因为这些公开的方法可以设置限制条件，所以可以让 用户按照自己想要的方式设置参数，保证数据安全，同时，也可以隐藏实现细节
- 注意：由于属性是受限制的，所以一般都用公开的方法setXxx和getXxx来设置和获得属性的值
- 小心构造器：构造器传参也会导致属性改变，因此一般会将传统的this.xxx=xxx改为this.setXxx(),即利用set方法来获取数据
### 继承(inheritance)
在开发中，常常会遇到两个类有两个类的属性大部分相同，只有小部分特殊的属性不同，这是就可以把这两个类相同的属性单独设置一个类，然后使用继承，基本语法为
```java
class 子类 extends 父类{}
```
这样操作之后子类就可以拥有父类的属性(当然要遵循访问修饰符)。接下来看看继承的细节：
1. 构造器：为了加载父类的属性，每次调用子类时(如创建和使用构造器)都会先调用父类(即使用构造器初始化父类)，并且在默认状况下，会优先调用父类的无参构造器。但上一节也说了，重写有参构造器之后会覆盖原有的无参构造器，这时要么就在父类创建无参构造器，要么就在子类使用super（后面还会讲）显式说明要调用父类的哪个构造器，方式为：
```java
public PC(cpu,disk,brand){
	super(cpu,disk);
	this.brand=brand;
}
```
其实super在使用无参构造器时也有，但隐藏了。注意此时super必须放在构造器第一行，还记得在构造器中调用同名构造器时this要放在第一行，此时会发生冲突，那不就会影响父类的初始化了吗？不就会影响父类的属性了吗？其实这个的本质就是父类构造器和同名构造器不能同时调用，但如果是子类是，调同名构造器时，这个构造器同样要调用父类构造器，所以一样可以使用父类的属性
2. Object：object时所有类的父类，他包括所有的基本数据类型和String，也包括像equals等很多方法，具体的看JavaAPI。
3. 父类构造器的调用会一直调用到object，因此调用子类的顺序就是先看子类有没有，再看父类有没有，再看父类的父类......但注意，不能越级调用，当父类和父类的父类都有同名属性，且父类是私有而父类的父类是公有时，编译器不会使用父类的父类的属性，而是直接报错
4. 一个子类只有一个父类
5. 建议子类和父类之间是有逻辑联系的，如person和student,animal和cat
### super
上文已经提到了super，也提到了和this的矛盾，但他和this的关系不止如此，他两有相似之处：都是用于区分成员变量和变量。但不同的是：this是从本类开始查找，本类没有就看父类，直到object，而super是直接从父类开始查找，直到object。两者都遵循就近原则，父类有，就不会调用父类的父类
### 多态
在oop中，将各个类联系了起来，也因为oop出现了更多的方法和属性，这些属性和方法也各有各的联系，那么，这些属性和方法该怎么划分呢？这就需要多态。多态分为方法多态和对象多态
- 方法多态
1. 在前一节将的方法重载就是多态的一种，对应的是同类的方法处理，让同名方法能多次使用。
2. 在父类和子类类中也有类似的形式，这就是方法重写。方法重写需要三个条件：父类和子类的方法名称，形参列表完全一样，并且子类的返回类型与父类一样或是父类返回类型的子类（如：父类是object，子类是String），同时子类的访问权限要大于等于父类的访问权限。

- 对象多态
在介绍对象多态之前先说明编译类型和运行类型。
```java
Scanner in=new Scanner(System.in);
```
在这一个熟悉的语句中，=左边的Scanner就是编译类型，右边的就是运行类型，其中编译类型一定要是运行类型的同类或子类。
编译类型决定了能在编译阶段调用那些方法和属性，运行类型决定了从运行时从哪个层级调用方法。
对象的多态就是基于编译类型和运行类型区分，一种为向上转型，一种为向下转型。
1.向上转型：编译类型为父类，运行类型为子类，如
```java
Object in=new Scanner();
```
由于编译类型是object，所以in只能调用object类的方法，但不能调用Scanner类的特有方法，运行类型是Scanner，所以当调用方法时先从Scanner类中查找，再按继承规则查找。当存在方法重写是，就有区别了。
2.向下转型：这可以看作是向上转型了延续，即把编译类型转换为子类，但注意，编译类型和运行类型任然遵循父类和子类的关系。基本语法为
```java
Scanner scanner=(Scanner) in
```
3.在这里还有对前面知识的补充：instanceoOf可以判断对象是否为另一个对象的子类,这里判断的是对象的运行类型
4.在关于对象多态的方法和属性调用时又涉及到另外一个规则：动态绑定机制。
总结来说：对于方法调用，能调用什么方法看编译类型，只能调用编译类型及其父类的方法，但从哪一级开始调用确实看运行类型，从运行类型这一层级开始向上找父类的方法。因此，如果子类重写了父类的方法，就会优先使用子类的方法。对于同名属性调用则分为直接调用和在方法内调用，如果是直接调用，就类似与向上转型，相当于编译类型调用他的属性，所以看编译类型，而在方法内调用则根据依据谁声明就使用谁，这个方法属于哪个类，就使用哪个类或其父类的属性。
5.有关多态的衍生：
多态数组：数组元素为数组类型的子类，如：
```java
Object[] arr=new Object[10];
arr[0]=new String("adc");
```
多态参数：实参为形参的子类
### Object类选讲（这里提到的方法都能通过alt+INS快捷生成重写）
1. equals和==
- equals():这是一个方法，原定义用于判断地址是否相同，且只能判断引用类型，但经常被重写，用于判断内容是否相同，这里也说一下常用的重写代码
```java
public boolean equals(object obj){
	if(this==obj){ //判断是否指向同一个对象
		return true;
	}
	if(obj instanceof Person){//先判断是否为同类或子类
		//如果是子类，就挨个比较
		//但是由于obj还是object类型，所以应该先向下转型
		Person p=(Person) obj;
		return this.name.equals(p.name)&&this.age==p.age;
	}
	return false;//如果不是同一个对象，也不是子类或同类，就返回false

```
- ==：这是一个操作符，能用于所以类型，当判断基本数据类型是判断值是否相同，当判断引用数据类型时时判断地址是否相同
2. hashcode
获取哈希值，基本用法为：obj.hashcode()
哈希值主要根据地址来确定，但不能把哈希值当作地址
当两个引用对象指向同一个对象时，哈希值一定相同，如果指向不同对象，哈希值一定不同。
3. toString()
默认返回：全类名+@+哈希值的十六进制
当输出时直接打印对象或拼接对象时，就会默认调用toString()
因此，在子类中也常常被重写，用于输出对象的内容
4. finalize()
该方法在实际开发中基本不会用到，但在JVM调优时会用到。
这个方法是用来释放资源，其实当对象不被引用时，系统会自动调用finalize()，但存在相应的垃圾回收机制（GC算法）
当然，也可以通过System,gc()来主动触发垃圾回收机制，但主动触发也有概率不被销毁
注意：不能直接显式调用这个方法，但可以在子类中重写该方法，可以实现自己想要的功能，比如：如果一个对象被销毁就发出警报
### 断点调试
快捷键：
F7：跳入方法内
alt+shift+F7:强制跳入Java源码
F8：逐行执行代码
shift+F8：跳出方法
F9：直接运行到下一个断点
注意：当运行高光停在某一行时代表该行已经执行完
### 零钱通中的编程思想
在这一章结束还做了给零钱通的小项目，也略有感悟。

1. 在实现代码时，一段代码就值完成一个任务，如在循环时就只完成一个循环，不要同时做判断
2. 在if语句进行判断时，优先判断错误条件，当错误时就直接跳出，然后在代码的后面直接写正确时该执行的语句，避免多分支
### 房屋出租系统
在这个项目中系统了解了要开发一个项目需要的步骤

1. 首先确定项目框架，这个项目用的时分层模式，按照用户的感知分为程序入口层，界面层，业务层（功能实现），数据层和工具类（软件会用到的各种方法）
2. 先写工具层，保证各种工具齐全，如IO方法，存储方法，判断方法等， 提升开发效率
3. 再写数据层，方便后续数据存储
4. 再写入口和界面，注意此时为了方便调试，可以在将要实现功能的地方先用输出语句代替，保证程序的基本逻辑正确
5. 最后一个个实现功能，完善功能层

### 结语
学到这，终于感觉到什么时面向对象编程了，也终于有了做项目的感觉了，继续加油！！！

 



> Written with [StackEdit中文版](https://stackedit.cn/).
